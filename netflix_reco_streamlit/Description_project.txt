Netflix Recommendation Engine
End-to-End Project Summary

This project builds a complete machine learning recommendation 
system‚Äîfrom raw data ingestion all the way to hybrid recommendations, 
user profiling, content similarity search, and interactive visualization using Streamlit.

Your app contains 4 major system pillars:

1. Data Pipeline & Pre-Processing

1.1 Loading Raw Data

Your pipeline loads multiple MovieLens + metadata files:

Ratings (userId, movieId, rating)

Movies (title, genres)

Movie metadata (overview, poster URL, actors, directors, TMDB info)

Genome tags & scores

‚û° Implemented in data_loader.py 

data_loader

1.2 Merging Metadata

MovieLens movies are merged with the metadata table:

Avoids column conflicts (renaming genres ‚Üí genres_meta)

Retains MovieLens genres and titles as the canonical labels

1.3 Cleaning the Data

Cleaning includes:

Filling missing text fields (actors, genres, overview)

Extracting missing release years from movie titles
e.g. "Toy Story (1995)" ‚Üí 1995

Converting ratings to float

‚û° Cleaned object is called full interaction table.

2. Feature Engineering (Most Important Section)

Implemented in features.py 

features

2.1 NLP-based Movie Embeddings (TF-IDF + SVD)

The movie overview text is transformed using TF-IDF.

Dimensionality is reduced using Truncated SVD.

Produces around 100 NLP embedding dimensions (nlp_0, nlp_1, ‚Ä¶).

These embeddings help measure similarity between movies by content.

2.2 User-Level Features

For every user:

Average rating

Rating standard deviation

Rating count

Like ratio (ratings ‚â• 4)

Preference for newer movies

Strictness score

Derived favourite genre

These profile features allow personalized model-driven recommendations.

2.3 Movie-Level Features

For every movie:

Average movie rating

Number of ratings

Popularity (log scaled)

Like ratio

Recency and trending flag

Combined NLP embeddings

2.4 Final ML Interaction Dataset

Every row is a (user, movie) pair with:

User features

Movie features

Text embeddings

Favourite genre match

Target variable: like (1 if rating ‚â• 4)

This dataset is used to train multiple ML models.

3. Machine Learning Models (Baseline + Tuned)

Implemented in models.py 

models

Your system trains two major groups of models:

3.1 Baseline Models

Logistic Regression

Random Forest

Gradient Boosting / XGBoost (if installed)

Evaluated on train / validation / test splits.

Metrics computed:

Accuracy

Precision

Recall

F1

ROC-AUC

All results are displayed visually in the Streamlit app.

3.2 Hyperparameter-Tuned Models

Using:

GridSearchCV (Logistic Regression)

RandomizedSearchCV (Random Forest / Boosting)

These tuned models often outperform the baseline due to optimized parameters.

3.3 Collaborative Filtering (Pure NumPy SVD)

You implement a matrix factorization model using SVD:

Decompose user-movie matrix into latent factors

Predict unseen movie ratings for each user

Generate recommendations based purely on preference patterns

This adds a collaborative filtering module alongside content + ML models.

4. Recommendation Engine

Implemented in recommender.py 

recommender

Your recommender has three major engines:

4.1 ML-Based Recommendations

For a selected user:

Take all unseen movies

Build feature rows using:

User profile

Movie stats

Text embeddings

Genre match

Feed into selected ML model

Sort by predicted probability of ‚Äúlike‚Äù

Display top-N with posters & metadata

This is a hybrid content + behavioural ML system.

4.2 SVD Collaborative Filtering

Uses learned user/item latent factors:

Computes predicted rating for all unseen movies

Returns highest-scoring recommendations

This does not use metadata, only user behaviour.

4.3 Similar Movies (Content-Based Search)

For any chosen movie:

Uses cosine similarity on NLP + numerical movie embeddings

Shows top-N similar titles with posters and genres

This helps the user explore content based on mood/theme.

5. User Profiling

Each user gets an automatically constructed profile:

Rating behaviour (average, strictness)

Top genres

Top actors

Top directors

Preference for modern movies

This is displayed in the UI under User Profiles & Personalized Recommendations.

6. Streamlit Front-End UI

Implemented in app.py 

app

Your app contains 4 main tabs:

üìä Tab 1: Data & EDA

Overview stats (users, movies, ratings)

Rating histograms

Genre distributions

ü§ñ Tab 2: Models

Performance comparison (baseline vs tuned)

F1 & ROC-AUC charts

Best hyperparameters table

üë§ Tab 3: User Recommendations

User profile visualization

ML-based recommendations (with posters)

SVD CF recommendations

üéû Tab 4: Similar Content

Movie similarity search

Poster + metadata display

The UI is clean, structured, and interactive.

7. Overall Project Architecture (High-Level)
Data Loading ‚Üí Cleaning ‚Üí Feature Engineering ‚Üí NLP Embeddings ‚Üí
Interaction Dataset ‚Üí Train/Test Split ‚Üí Models (Baseline + Tuned) ‚Üí
SVD Collaborative Filtering ‚Üí User Profile ‚Üí ML/SVD Recommendations ‚Üí
Similar Movie Search ‚Üí Streamlit Frontend

‚≠ê Final Summary (Concise Version)

Your project is a full-stack, hybrid recommendation engine that combines:

‚úî Content-based filtering (TF-IDF + SVD)
‚úî Collaborative filtering (matrix factorization)
‚úî Machine learning models (LogReg, RF, XGBoost)
‚úî User profiling
‚úî Streamlit dashboard

It is equivalent to what Netflix, YouTube, or Amazon use:

A multi-model recommendation system that understands both movie content and user behaviour, learns preferences, and provides personalized suggestions.